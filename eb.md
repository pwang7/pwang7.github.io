# 无锁化编程场景下的垃圾回收机制（一）

之前的一篇[Blog](gc_and_lock_free.html)里介绍了无锁化编程场景下需要垃圾回收机制，我称之为确定型垃圾回收机制（GC），这是相对Java的GC而言。
Java的GC什么时候回收内存，这对开发者来说是不确定也不可预知的。
而无锁化编程场景下的内存回收，是确定并可预知的，同时对开发者来说也是透明的，即开发者不用关心无锁化编程场景下的垃圾回收。
确定型GC最大的好处是，对性能的开销很小，这也是相对Java的GC而言。为什么确定型GC性能好？
原因很简单，因为确定型GC只处理无锁化编程场景下的内存回收，需要考虑的情况少很多，而Java的GC要处理各种场景下的内存回收，显然Java的GC要复杂得多。
套用第一性原理，简单的东西，才能效率高，性能好。

此外，在之前的[Blog](gc_and_lock_free.html)里也提到，通常情况下开发者自行管理内存并不复杂，但是无锁化编程场景是个例外。
因为没有锁，无锁化编程无法保证共享数据在某个时刻只被一个线程独享，
因此在无锁化编程场景下，某个线程不能在消费完共享数据里的某个对象后马上delete以回收其内存。
不然的话，一个线程把一个共享对象delete了，如果另一个线程仍然持有该对象的指针，那这个指针就变成野指针了，一旦访问野指针会导致程序崩溃。
于是，在无锁化编程场景下，确定型GC帮助开发者回收内存，同时确定型GC对开发者透明，让开发者无需关心何时内存被回收。
有了确定型GC的帮助，用C、C++这类没有GC的语言进行无锁化编程的难度大大降低。

## Epoch-based Memory Reclaimation（EB）

下面介绍一种比较常见的确定型GC，Epoch-based Memory Reclaimation（简称EB）。
EB核心要解决的问题是，什么时候才能安全的回收内存，即确保被delete的对象没有被任何线程访问时，才可以安全回收。
如果采用引用计数的方式来跟踪每个对象是否还被线程在访问，这种方式成本太高，而且效率太差。
EB的做法是把待回收对象分成不同的阶段，不着急马上回收每个可以被安全回收的对象，而是批量按阶段回收。
这是一种以空间换时间的做法，不马上回收每个可以被安全回收的对象，降低了对性能的影响，但也占用了更多的内存。

EB定义了三个阶段，分别为阶段0、阶段1、阶段2，而且每时每刻EB只能处于一个阶段，同时EB给每个待回收对象都标识其所处阶段。
EB在三个阶段之间单向轮转，或从阶段0进入阶段1，或从阶段1进入阶段2，或从阶段2回到阶段0，循环往复。
同时EB定义了阶段跨越的条件，条件满足才能从当前阶段转到到下个阶段。

EB定义这三个阶段，以及阶段跨越的条件，是为了保证可以安全批量回收内存。EB保证可以安全回收两个阶段前的待回收对象。
比如EB当前处于阶段2，则EB可以安全回收阶段0的对象；再比如EB当前处于阶段0， 则EB可以安全回收阶段1的对象。
为什么EB可以安全回收处于两个阶段前的对象？下面先用一段代码描述下EB的使用场景，然后再介绍EB如何安全回收内存。

### Epoch-based Memory Reclaimation（EB）的用法

还是沿用[Blog](gc_and_lock_free.html)里介绍的无锁化堆栈的例子。
无锁化堆栈是多个线程的共享数据，栈顶节点是被多个线程共享的对象。
如果某个线程调用无锁化堆栈的出栈方法取出栈顶节点并消费后，并不能马上delete这个栈顶节点以回收该节点的内存，
因为无法保证没有其他线程也在访问该栈顶节点，即无法保证没有其他线程也在调用出栈方法——读取该栈顶节点的指针并准备修改栈顶节点的next域。
下面的代码片段采用EB来管理待回收栈顶节点，EB的做法是不着急马上回收栈顶节点的内存，先保存下来后续再批量回收。
```
struct Node {
    void* data;
    std::atomic< Node * > next;
};

std::atomic<Node *> top; // 栈顶
top.store( nullptr ); // 初始化栈顶为空指针

bool push( Node* new_node ) {
    // 标识入栈操作要修改共享数据
    EB::enter();

    Node * cur_top = top.load();
    while ( true ) {
        new_node->next.store( cur_top );
        
        // CAS调用修改栈顶
        if ( top.compare_exchange_weak(
                cur_top, new_node )) {
            break; // 修改栈顶成功
        }
    }

    // 结束修改共享数据，同时入栈操作没有要回收的内存
    EB::leave(NULL);
    return true;
}

Node * pop() {
    // 标识出栈操作要修改共享数据
    EB::enter();

    Node * cur_top;
    while ( true ) {
        Node * cur_top = top.load();
        if ( cur_top == nullptr ) {
            return nullptr; // 堆栈为空
        }
        Node * next = cur_top->next.load();
        
        // CAS调用修改栈顶
        if ( top.compare_exchange_weak(
                cur_top, next )) {
            break; // 修改栈顶成功
        }
    }

    // 结束修改共享数据，出栈节点指针传给EB由其后续回收
    EB::leave(cur_top);
    return cur_top;
}
```
上面的代码片段里可以看到对于入栈`push`和出栈`pop`这两个函数，都用`EB::enter()`和`EB::enter()`把对共享数据——无锁化堆栈的修改操作标识出来。
入栈操作不产生待回收对象，出栈操作里把出栈的栈顶节点的指针传给`EB::enter()`，由EB后续回收该节点的内存。
虽然`EB::enter()`和`EB::enter()`有点像是访问由锁保护的临界区以修改共享数据：
```
enter_critical_section(); // 进入临界区

// 修改共享数据

exit_critical_section(); // 离开临界区
```
但是其实EB的做法和基于锁实现的临界区的做法大相径庭。下面详细介绍EB的具体实现。

### Epoch-based Memory Reclaimation（EB）的实现

首先，EB维护一个全局队列，用于保存待回收的对象的指针，并且EB用一个全局变量标识出当前所处的阶段（称为全局阶段），初始为阶段0。
然后，EB为每个线程维护一个本地队列，用于保存该线程消费完要回收的对象，同时EB为每个线程用线程本地变量维护一份EB全局阶段的副本（称为本地阶段）。
接下来每个线程把要访问共享数据进行修改的操作，都用`EB::enter()`和`EB::enter()`标识出来，并且把待回收的对象指针通过`EB::enter()`传给EB来后续回收。
`EB::enter()`和`EB::enter()`的实现如下所示。

`EB::enter()`的操作：
1. 如果是该线程第一次调用`EB::enter()`，则为该线程创建一个本地队列，用于保存该线程待回收的对象，并创建本地阶段的变量；
2. 读取当前EB全局阶段，并复制给本地阶段变量；
3. 尝试跨越至下一阶段并尝试回收内存：
    - 先检查是否有其他线程正在修改共享数据，有则放弃；
    - 如果没有其他线程正在修改共享数据，再检查每个线程的本地阶段是否一致，如有不一致则放弃；
    - 前面两个条件满足，则EB的全局阶段跨越至下个阶段，并从EB维护的全局队列中回收两个阶段前的对象的内存；
4. 标记当前线程正在修改共享数据；

可以看出，`EB::enter()`负责标识某个线程正在修改共享数据，并尝试回收内存。
在尝试回收内存时，`EB::enter()`先检查阶段跨越的条件，满足条件时全局阶段进入下一个阶段，然后回收全局阶段两个阶段前的对象。
因此，EB回收内存的确定性指的就是`EB::enter()`会负责回收内存。
当然`EB::enter()`并不能保证每次被调用就一定能成功回收内存，因为要先满足阶段跨越的条件，满足之后才能回收两个阶段前的对象的内存。
而且为了减少内存回收对性能的影响，`EB::enter()`是被调用一定次数之后才尝试回收内存。
此外，如果`EB::enter()`成功跨越全局阶段至下个阶段，并不意味着每个线程的本地阶段也都同步到下个阶段，
这要等每个线程下次调用`EB::enter()`完成全局阶段和本地阶段的同步。同时线程本地阶段最多落后全局阶段一个阶段，不会落后两个阶段。

`EB::leave(void *)`的操作：
1. 标记当前线程没有在修改共享数据；
2. 把调用`EB::leave(void *)`输入的待回收对象指针存入本地线程的队列（只存入非空对象指针），并标记待回收对象指针所处的阶段为当前本地阶段（不是用全局阶段标记）；
3. 如果本地线程的队列已满，则把本地队列里的待回收对象都移到EB维护的全局队列。

可以看出，`EB::leave()`比较简单。有一个细节要注意，`EB::leave()`要给输入的待回收对象指针标记其所处线程的本地阶段，而不是全局阶段，其原因下文解释。

### 为什么EB能安全回收内存？

那为什么EB回收当前全局阶段前两个阶段的对象是安全的呢？

首先，在一个线程里，这个线程函数的操作是串行执行的。
当一个线程处于某个阶段，那么这个线程不会还保留着前一个阶段的待回收对象的指针，不然这个对象就不是待回收的，该对象应该是线程仍然在访问的对象。
线程还在访问的对象是不应该交给EB来回收的，只有线程不再访问的对象才应该交给EB做后续回收。
因此，对每个线程来说，其当前本地阶段的前一个阶段的待回收对象是可以被安全回收的。

其次，EB的阶段跨越条件保证了，每个线程的本地阶段要么跟全局阶段一致，要么处于全局阶段的前一阶段，不可能出现某个线程的本地阶段处于全局阶段的前两个阶段。
回想`EB::enter()`里第三步检查阶段跨越的两个条件：
- 当前没有任何线程在修改共享数据；
- 所有线程的本地阶段都一致。

阶段跨越的第一个条件比较好理解，还有线程在修改共享数据时，不能跨越至下个阶段。
阶段跨越的第二个条件，要求全局阶段跨越至下个阶段前，所有线程的本地阶段都一致。
这就保证了线程的本地阶段最多落后全局阶段一个阶段，不会落后两个阶段。
前面提到，对每个线程来说，其当前本地阶段的前一个阶段的待回收对象是可以被安全回收的，
因为线程的本地阶段最多落后全局阶段一个阶段，而且每个线程调用`EB::leave()`时都用其本地阶段标识待回收对象，
那么对于全局阶段来说，当前全局阶段的前两个阶段的待回收对象是可以被安全回收的。
