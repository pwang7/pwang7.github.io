# 无锁化编程场景下的垃圾回收机制（一）

之前的一篇Blog里介绍了无锁化编程场景下的垃圾回收机制，我称之为确定型垃圾回收机制（GC），这是相对Java的GC而言。
Java的GC什么时候回收内存，这对开发者来说是不确定也不可预知的，这是Java的一大好处，简化开发者对内存的管理，让开发者无需关心垃圾回收。
而无锁化编程场景下的内存回收，是可以确定的，同时对开发者来说也是透明的，即开发者仍然不用关心无锁化编程场景下的垃圾回收。
确定型GC最大的好处是，对性能的开销很小，这也是相对Java的GC而言。为什么确定型GC性能好？
原因很简单，因为确定型GC只处理无锁化编程场景下的内存回收，需要考虑的情况少很多，而Java的GC要处理各种场景下的内存回收，显然Java的GC要复杂得多。
套用第一性原理，简单的东西，才能效率高，性能好。

另外一点，在之前的Blog里也提到，通常情况下开发者自行管理内存并不复杂，但是无锁化编程场景是个例外。
因为没有锁，无锁化编程无法保证某个对象只被一个线程独享，因此对一个线程来说不能在消费完对象后马上delete以回收其内存，避免野指针问题。
于是，确定型GC在无锁化编程场景下，帮助开发者回收内存，同时对开发者做到透明，让开发者无需关心何时内存被回收。

## Epoch-based Memory Reclaimation（EB）

下面我介绍一种常见的确定型GC，Epoch-based Memory Reclaimation（EB）。EB的原理跟Java的GC有类似的地方。
Java的GC定义了新生代、老生代、永久代，用于存放不同生命周期的对象，并且不同的阶段有不同的内存回收策略。
EB定义了三个阶段，分别为阶段0、1、2，每个阶段也用来存放不同生命周期的对象，也采用不同的内存回收策略。
EB定义了阶段跨越的条件，满足条件即可从阶段0进入阶段1，或从阶段1进入阶段2，或从阶段2回到阶段0，即这三个阶段单向轮回。
跟Java的GC不一样的地方在于，每个时刻EB只能处于三个阶段之一，不能同时处于多个阶段，而Java的GC同时存在新生代、老生代、永久代。

EB核心要解决的问题是，什么时候才能安全的回收内存，即确保被delete的对象没有任何线程在访问时，才可以安全回收。
但是如果用引用计数的方式来跟踪每个对象是否还被线程在访问，这种方式成本太高，而且效率太差。
EB的做法是，不着急马上回收每个可以被安全回收的对象，而是批量回收，这样提高效率，那接下来EB要定义如何批量回收内存以保证安全。
之前提到EB定义了三个阶段，而且每时每刻EB只能处于一个阶段。对于EB来说，可以安全批量回收处于两个阶段前的对象。
比如EB当前处于阶段2，则EB可以安全回收阶段0的对象；再比如EB当前处于阶段0， 则EB可以安全回收阶段1的对象。
为什么EB可以安全回收处于两个阶段前的对象？这个跟EB定义的阶段跨越的条件相关。前面提到，只有满足阶段跨越的条件，EB才能从一个阶段进入下一个阶段。
下面先用一段代码描述下EB的使用场景，然后再介绍EB如何实现阶段跨越并批量回收内存。

### Epoch-based Memory Reclaimation（EB）的用法

下面的代码片段来自之前Blog里介绍的无锁化堆栈，也提到了无锁化堆栈的出栈方法在取出栈顶节点并被某个线程消费后，并不能马上回收栈顶节点的内存，
因为无法保证没有其他线程没有访问该栈顶节点，即无法保证没有其他线程读取了该栈顶节点的指针并准备修改栈顶节点的next域。
前面提到EB的做法是，先不着急马上回收栈顶节点的内存。
```
struct Node {
    void* data;
    std::atomic< Node * > next;
};

std::atomic<Node *> top; // 栈顶
top.store( nullptr ); // 初始化栈顶为空指针

bool push( Node* new_node ) {
    // 标识入栈操作要开始修改共享数据
    EB::enter();

    Node * cur_top = top.load();
    while ( true ) {
        new_node->next.store( cur_top );
        
        // CAS调用修改栈顶
        if ( top.compare_exchange_weak(
                cur_top, new_node )) {
            break; // 修改栈顶成功
        }
    }

    // 结束修改共享数据，同时入栈操作没有要回收的内存
    EB::leave(NULL);
    return true;
}

Node * pop() {
    // 标识出栈操作要开始修改共享数据
    EB::enter();

    Node * cur_top;
    while ( true ) {
        Node * cur_top = top.load();
        if ( cur_top == nullptr ) {
            return nullptr; // 堆栈为空
        }
        Node * next = cur_top->next.load();
        
        // CAS调用修改栈顶
        if ( top.compare_exchange_weak(
                cur_top, next )) {
            break; // 修改栈顶成功
        }
    }

    // 结束修改共享数据，出栈节点指针传给EB由其后续回收
    EB::leave(cur_top);
    return cur_top;
}
```
上面的代码片段里可以看到对于入栈push和出栈pop这两个函数，都用`EB::enter()`和`EB::enter()`把对无锁化堆栈的访问操作标识出来。
`EB::enter()`和`EB::enter()`有点像是访问由锁保护的临界区以修改共享数据：
```
enter_critical_section(); // 进入临界区

// 修改共享数据

exit_critical_section(); // 离开临界区
```
但是其实EB的做法和临界区的做法大相径庭。

首先EB维护一个全局队列，用于保存要回收的对象，并且EB标识当前所处的阶段，初始阶段为0；然后EB为每个线程维护一个本地队列，用于保存该线程消费完要回收的对象。
接下来每个线程把要访问共享数据的部分，都用`EB::enter()`和`EB::enter()`标识出来。

调用`EB::enter()`会做如下操作：
1. 读取当前EB所处阶段；
2. 如果是该线程第一次调用`EB::enter()`，则为该线程生成一个本地队列，用于保存该线程要回收的对象；
3. 标记当前线程正准备修改共享数据。

调用`EB::leave(void *)`会做如下操作：
1. 把调用`EB::leave(void *)`输入的待回收非空对象指针存入本地线程的队列，并标记待回收对象指针所处的阶段为当前阶段；
2. 标记当前线程没有在访问共享数据；
3. 查询是否有其他线程处于正在修改共享数据的状态，即有线程调用了`EB::enter()`，但尚未调用`EB::leave()`，如果有则返回；
4. 当没有任何线程在修改共享数据时，并且所有线程都处于同一个阶段时，EB跨越到下一个阶段（0->1，1->2，或2->0）；
4. 把本地线程的队列里的待回收对象指针加入EB维护的全局队列；
5. 检查全局队列里的待回收对象，并回收处于两个阶段前的对象的内存。

可以看出，EB跨越阶段的条件是，`EB::leave()`判断是否有线程在准备修改共享数据，如果没有并且所有线程都处于同一个阶段，则EB所处阶段跨越到下一个阶段。
为什么删除两个阶段前的对象是安全的呢？先看下面执行入栈和出栈操作的线程函数代码片段：
```
while true {
    Node * new_node = new Node();
    new_node.data = ...;
    push( new_node ); // 入栈新栈顶

    ... // 其他操作

    Node * pop_node = pop();
    if ( pop_node ) {
        // 消费出栈节点
        ...
    }
}

```
上面的线程函数代码里，先入栈，执行其他操作，再出栈，消费出栈节点，然后无限循环。在一个线程里，这个线程函数的操作是串行执行的。
假定有两个线程在执行上面的函数，并发访问共享堆栈。用`+`表示线程在执行入栈push()函数里`EB::enter()`和`EB::enter()`之间的部分，即修改栈顶为新节点；
用`-`表示线程在执行出栈pop()函数里`EB::enter()`和`EB::enter()`之间的部分，即移除栈顶节点并把下一个节点设为新的栈顶；
用`.`表示线程在执行非入栈和出栈的操作；用`|`表示EB阶段的跨越。如下为两个线程的某次运行时示意图（忽略运行时的`EB::enter()`和`EB::enter()`操作，以及线程的阻塞）：
```
..+++...---..++++.---|..+++..---..++++...|----.+++..----..+++|..---.++++..-----..|
....++++..----..+++..|.---....+++++...---|..++++.----..+++++.|.------..++++...---|
 阶段0                 阶段1               阶段2                阶段0
```
第一行表示第一个线程，第二行表示第二个线程，第三行标识出EB所处的阶段。
由上面的线程运行时示意图可见：
* 初始时EB处于阶段0，当EB刚从阶段0跨越到阶段1时，线程1在消费出栈节点，该出栈节点是阶段0的最后一个被`EB::enter()`标识的待回收对象，线程二在执行入栈后出栈前的其他操作，此时尚没有任何两阶段前的对象可以回收；
* 当EB从阶段1刚跨越到阶段2时，线程1刚执行完入栈后的其他操作准备执行出栈操作，线程2正在消费出栈节点，该出栈节点是节点1的最后一个被`EB::enter()`标识的待回收对象，此时可以回收属于阶段0的所有对象。

如上图所示，当EB处于阶段2时，可以保证没有任何线程拥有阶段0的对象的指针，从而可以安全回收阶段0的对象，这是由EB的阶段跨越条件保证的。
回顾EB的阶段跨越条件（`EB::leave()`里的第4步操作）：
1. 当前没有任何线程在修改共享数据；
2. 所有线程都处于同一个阶段。

EB的阶段跨越的第一个条件比较好理解，如果有线程正在修改共享数据，即该线程调用了`EB::enter()`，但尚未调用`EB::leave()`，此时该线程会有对共享对象的指针，不能回收该阶段的对象。
阶段跨越的第二个条件，要求所有线程都处于同一个阶段，这个怎么理解呢？看下面的线程运行时示意图，用`=`表示线程被阻塞：
```
..+++...---..++++.---|..+++..---..++++...|----.+++..----..+++|..---.++++..-----..|
....++++..----..+++..|.---....+++++....--|==========--..++++.|.------..++++...---|
 阶段0                 阶段1            阶段2                  阶段0
```
如上图所示，线程1在阶段2里被阻塞了一阵，在线程2被阻塞期间，线程1虽然查到没有其他线程在修改共享数据，但是此时不能跨越到阶段0，不然线程2因为休眠导致还处于阶段2，而线程1已跨越到阶段0，这是EB不允许的，因为EB要求每时每刻只能处于一个阶段。
