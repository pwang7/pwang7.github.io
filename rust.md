# 对于Rust语言的一些体会

Rust语言是一门非常优秀的编程语言，不仅[性能好](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html)，
而且Rust实现了各种机制来规约开发者以减少人为bug，切实落实了在编译阶段尽可能发现更多bug这一理念。
因此Rust极大地减少了程序运行时的错误，这给开发者带来了极大的好处，毕竟程序运行时阶段的偶发bug最难调试，能在编译阶段尽可能发现bug再好不过。
国内开源圈某位前辈讲，Rust是下一代的C/C++，Go是下一代的Java，深以为然。
这里谈一下我对Rust粗浅的体会。

## 对开发者的规约

首先，Rust很重要的一个理念是，对开发者有各种规约，使得开发者不能随意乱写代码，这样从根本上杜绝了很多人为带来的bug。
比如Rust的Ownership机制，保证一个变量或一个对象有且仅有一个Owner，同时变量/对象可以有只读引用和修改引用。
Rust严格规约变量/对象的引用机制：
* 可以有多个对该变量/对象的只读引用，但是变量/对象的修改引用只能有一个；
* 变量/对象的只读引用和修改引用不能同时共存，即有了修改引用就不能再有任何只读引用，反之亦然。

Ownership机制这么严格的规约，是要杜绝C/C++里因为指针导致的各种问题，诸如野指针、并发修改、double delete等指针非法访问问题。
C/C++实在是太灵活了，开发者想怎么写就怎么写，导致了C/C++在实现多线程编程时，很容易出问题，一不小心就出现指针非法访问。

那为什么要对开发者进行规约呢？本质上是要尽可能减少人为的错误。
先举Google的SRE的例子，Google的SRE是Google对于DevOps的落地实践。
SRE最大的特点是，切实把DevOps的理念和规约落实到一系列SRE工具里，使得Google的工程师必须遵守SRE工具里落实的各种规约和制度。
Google的SRE涉及大量的工具，包括持续集成、持续发布、监控告警和日志等多个环节，
这样一方面提高了应用上线的自动化程度，诸如滚动更新、灰度发布、一键回滚等等，
更重要的是把很多对开发者的规约落实到工具里，比如单元测试和集成测试等各种测试是否通过、单元测试覆盖率是否达标，等等。
因此，SRE涉及的各种工具落实了各项应用上线前的规约和制度，从根本上保证了开发者必须遵守这些规章制度，不然程序无法上线，
进而极大地减少了上线过程中的人为错误，保证生成环境的稳定运行。但是SRE无法在开发过程对开发者进行规约。

Rust对开发过程进行了严格的规约。Rust编译器实现了各种机制，在编译器里直接落实了对开发者的各项规约，从编程机制上杜绝了诸如非法指针访问等一系列问题。
有了Rust，再加上SRE，可以从应用开发阶段到应用上线交付阶段，落实对开发者的各项规约。一旦开发者不遵守规约，那要么程序编译不通过，要么程序无法上线。
这样一来，真正从机制上减少了人为错误的可能性，极大提高了程序的质量。

## 博采众长

其次，Rust作为一门新的语言，吸收了很多经典编程语言的优点，特别是Rust从C/C++和Haskell借鉴了很多优点。

### 无需GC管理内存

Rust从C++借鉴了智能指针的理念，这样Rust无需垃圾回收机制GC，也能做到简化开发者管理内存的复杂度，而且比GC管理内存效率更高，从而提高了程序的性能。

### 函数式编程

Rust从Haskell借鉴了很多函数式编程的理念，诸如闭包、纯函数、不可变对象等等。
函数式编程相比面向过程编程，很大的一个好处是代码量相对少，因为函数式编程的表达能力强，特别是在循环处理方面。
比如针对集合元素的处理，如果用函数式编程，不需要采用循环结构，用map、filter、fold等函数式编程的函数可以实现对每个集合元素的访问处理；
而面向过程编程，需要采用循环结构处理集合，需要挨个遍历集合元素，代码量会比较大。函数式编程减少代码量，一方面提高编程效率，另一方面减少bug。

此外，函数式编程留给编译器优化的空间比面向过程编程更大。
比如面向过程编程采用循环结构来遍历集合，编译器常用的优化方式是循环展开，减少二进制程序里的分支判断，
这样尽可能采用指令预读机制加速程序执行，减少CPU因为分支判断错误导致的指令加载带来的等待。
但是循环展开的优化空间有限，当集合元素非常多，循环迭代次数多时，编译器不可能把所有的循环迭代都展开。
而采用函数式编程处理集合元素，编译器不仅可以采用循环展开利用预读机制来优化性能，还可以采用多核并行执行的优化策略，大大提升了程序的运行速度。

### 完备的类型系统

Rust实现了完备的类型系统，特别是用Option枚举类型代替了空指针，从跟上杜绝了空指针带来的各种非法访问问题。
当用指针访问一个对象时，如果该指针是空指针，则用空指针调用该对象/该类型的任何方式都会导致程序崩溃。
因此对象/类型的方法对于空指针是无效的，用抽象代数的说法，类型的方法对于该类型的对象指针来说是不完备的，因为有空指针的存在。
Rust用Option枚举类型取代了空指针，对Option对象的访问要采用模式匹配，分别处理Option是None（为空）和Some（不为空）的情况。
这样一来Option对象的方法，特别是map函数，不论Option是None还是Some都可以安全的调用。
用抽象代数的说法，Option类型的方法对于该类型的任何对象都是完备的。

### 强制错误处理

再比如错误处理，Rust用Result枚举类型表示函数返回值正常（Ok)和错误（Err）两种状态，因此函数不论返回正常和错误，其返回值都是Result类型。
而且Rust编译器强制要求，当函数返回值是Result类型时，开发者必须显示处理返回结果，不能不处理。
因此Rust从软件工程角度强制保证了开发者必须进行错误处理。

### 异步编程

Rust的异步编程是一大亮点。Rust采用Future机制和异步函数，完全杜绝了传统异步编程里的回调函数。
一方面避免了回调函数过多的噩梦，另一方面让开发者采用同步编程的逻辑来写异步编程的代码，极大地提升了代码的可读性。

传统的异步编程，开发者要实现各种回调函数，并把回调函数注册给相应的异步事件，等事件发生的时候执行回调函数。
采用回调函数最大的缺点是使得代码可读性变差，异步编程的请求和响应处理逻辑往往是分开的，异步请求在一个函数里，异步响应在另外的回调函数里。
当要处理的异步事件多、回调函数多的时候，代码的可维护性大大降低。

Rust的异步编程，采用Future机制，并定义异步函数，所有异步的操作都要放到异步函数里。
异步函数里请求的返回结果定义为Future，Future代表未来返回的结果，
然后调用Future的await方法来等待Future返回，返回后继续执行对Future返回结果的处理。
从发出请求、Future的await等待，到Future返回处理请求响应，这些操作都可以定义在一个异步函数李。
这样一来异步函数里对请求和响应的处理都在一起，无需分开，而且也没有回调函数，代码可读性大大提升，方便了开发者对代码的维护。

进一步，Rust的异步编程，使得开发者无需显式管理线程，于是开发者无需显式调用同步互斥等各种锁操作。
异步函数里调用Future的await方法来等待Future返回，这使得该异步函数进入阻塞状态，于是Rust的异步调度框架转而执行其他的异步函数。
换句话讲，Rust的异步编程采用的是协程（Coroutine）机制，异步函数可以主动通知调度框架要进入阻塞状态，把CPU执行时间让给其他异步函数。

Rust的异步编程，极大大地方便了开发者，不仅无需采用线程、同步互斥锁，以及回调函数等复杂的操作，
而且可以采用同步编程逻辑来实现异步编程，降低了异步编程的门槛并杜绝了由于使用线程、锁、回调函数带来的潜在bug。

## Rust的缺点

凡是都有利有弊，优点同时也是缺点。Rust语言虽然很优秀，但也还有不少缺点。

### 上手难

Rust对开发者的各种规约，导致了Rust的学习门槛很高，即使是资深的开发者在学习Rust阶段也经常碰到代码改很久也编译不通过的问题。
毕竟简单的东西才更容易推广，Rust在降低编程难度方面还有很多工作要做。既要落实对开发者的规约，又要让开发者容易上手，这需要在语言设计方面有很多权衡。

### 引用生命周期

Rust的Ownership机制强制要求，对变量/对象的引用的生命周期不能比变量/对象本身的生命周期长，不然就出现野指针问题。
但是Rust编译器并不能保证在编译阶段能推导出每个引用的生命周期。
比如引用作为函数参数、引用作为结构体成员变量时，Rust不能判断引用的生命周期是否长于其变量/对象本身的生命周期长，
这时Rust要求开发者显式标注出引用的生命周期，比如开发者要标注出采用某个引用作为成员变量的结构体的生命周期不会比该引用的生命周期长，
保证结构体的成员变量不会引用一个已经消亡的变量/对象本身的生命周期长，不然就出现野指针问题。

但是Rust的引用生命周期语法很不容易理解，而且引用生命周期语法设计成跟泛型的定义一样，对引用生命周期的定义和对泛型的定义混杂在一起，
使得初学者很难理解引用生命周期的语义。

### 宏

Rust的宏非常强大，Rust的宏在编译阶段执行，甚至可以作为编译器插件，让开发者扩展Rust的语法。

但是宏过于灵活，导致的问题是对于宏的使用的方式不统一，不同开发者可以自行定义宏的使用方式，这带来很大的代码可读性问题和库的通用问题。
因为宏的使用方式不统一，使得开发者必须了解不同宏的使用方式，这显然不利于开发者复用其他开发者写得宏，进而导致不便于复用其他开发者写得库。

而且目前Rust的宏还没有支持命名空间，如果程序依赖的不同库里有同名的宏会导致冲突。

### 外部函数调用（FFI）

Rust支持跨语言调用，比如Rust调用C/C++实现的库函数，或者C/C++语言调用Rust实现的库函数。

但是Rust的外部函数调用还不够友好，特别是在跨语言库函数调用传递复杂参数的时候，很容易出问题。
比如C/C++的某个库函数要求传入一个结构体参数：
```
struct Person {
    const char[64] name;
    int age;
}
```
这个结构体里的`name`成员变量是长度为64的数组，此外C/C++里`name`变量也是一个指向`const char *`类型的指针。
Rust初学者会以为该结构体等同于Rust定义的如下结构体：
```
#[repr(C)]
struct Person {
    name: * const c_char,
    age: c_int,
}

let cstr_name = CString::from("ABCD");
let c_name = c_name.as_c_str();

let person = Person {
    name: c_name.as_ptr(),
    age: 38,
}
```
并打算把`person`变量作为函数参数传递给C/C++的库函数。但是这么做是错误的，正确的做法是：
```
#[repr(C)]
struct Person {
    name: [u8; 64],
    age: c_int,
}

let cstr_name = CString::from("ABCD");
let c_name = [u8; 64];
c_name.copy_from_slice(cstr_name.as_bytes());

let person = Person {
    name: c_name,
    age: 38,
}
```
即C/C++里定义的`const char[64] name`等同Rust里定义的`name: [u8; 64]`，
而C/C++里定义的`const char* name`才等同Rust里定义的`name: * const c_char`。
